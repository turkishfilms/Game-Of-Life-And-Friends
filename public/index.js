
const rlees2 = ["#N p856glidergun_synth\n#C Glider synthesis of period-856 glider gun.\n#C https://conwaylife.com/wiki/Period-856_glider_gun\n#O muzik and Dave Greene, February 2, 2022\n#C https://conwaylife.com/forums/viewtopic.php?p=141165#p141165\nx = 1354, y = 214, rule = B3/S23\n582bobo$583b2o$583bo5$338bo251bo$336bobo223bo25bobo$337b2o224b2o24b2o$\n562b2o213bo$334bo440b2o$332bobo441b2o$333b2o78bo153bo$412bo155b2o$412b\n3o152b2o5$753bobo$753b2o$754bo4$746bo$746bobo$325bo420b2o$326b2o64bo$\n325b2o63b2o810bo$391b2o810bo$920bobo278b3o147bo$340bo421bobo156b2o428b\nobo$341bo420b2o157bo429b2o$339b3o421bo2$1345bo$1206bobo134b2o$755bo\n451b2o135b2o$755bobo449bo$755b2o3$1265bo$1265bobo$1265b2o$1218bo$1219b\n2o$1218b2o114bobo$1007bo326b2o$1006bo44bo283bo$1006b3o40b2o$1050b2o$\n669b2o298b2o298b2o$668b4o296b4o296b4o$664bob2ob2obo291bob2ob2obo291bob\n2ob2obo$663bo2b2o295bo2b2o295bo2b2o$662b3o2b2o2b2o289b3o2b2o2b2o289b3o\n2b2o2b2o$662b3o2bob4o289b3o2bob4o289b3o2bob4o$85bo577bo2bo3bo2bo289bo\n2bo3bo2bo289bo2bo3bo2bo$86bo577b4obo2b3o289b4obo2b3o289b4obo2b3o$84b3o\n577b2o2b2o2b3o289b2o2b2o2b3o289b2o2b2o2b3o$147bo236bo284b2o2bo295b2o2b\no295b2o2bo$145b2o238b2o277bob2ob2obo291bob2ob2obo291bob2ob2obo$146b2o\n236b2o279b4o296b4o296b4o$666b2o298b2o298b2o$409bo$408bo$408b3o2$163bo$\n163bobo$163b2o2$167bo$167bobo$167b2o3$1216bo$1217b2o$929bobo284b2o$\n930b2o346b2o$930bo347b2o$926bo$927bo$337bo587b3o$337b2o$336bobo$117bo$\n118b2o$117b2o$8bo116bo$9bo115bobo$7b3o115b2o292b2ob6o291b2ob6o291b2ob\n6o291b2ob6o$36bo382b2ob6o291b2ob6o291b2ob6o291b2ob6o9b3o$34b2o383b2o\n298b2o298b2o298b2o16bo$35b2o93bo288b2o5b2o291b2o5b2o254b2o35b2o5b2o\n254b2o35b2o5b2o10bo$129b2o288b2o5b2o291b2o5b2o243b2o2bo6bo2bo33b2o5b2o\n243b2o2bo6bo2bo33b2o5b2o$129bobo287b2o5b2o291b2o5b2o239b2o2b2o3bo42b2o\n5b2o239b2o2b2o3bo42b2o5b2o$426b2o298b2o239b2o7bo5bo2bo40b2o239b2o7bo5b\no2bo40b2o$355bo63b6ob2o291b6ob2o244b4o5bo2bo34b6ob2o244b4o5bo2bo34b6ob\n2o$353bobo63b6ob2o291b6ob2o253bobo35b6ob2o253bobo35b6ob2o$52bo301b2o\n626bo269b2o28bo$52bobo267b3o927b2o$52b2o270bo26bo630b2o298b2o$323bo25b\nobo50b2o565b2o11b2o285b2o11b2o$56bo293b2o50bobo23bo540bo2bo296bo2bo$\n56bobo343bo24bo871b2o$56b2o269b2o98b3o197b2o298b2o40bo2bo254b2o40bo2bo\n26b2o$327bo70b2o227bo299bo40bo2bo255bo40bo2bo$326b2o2b3o65bobo225b2o2b\n3o293b2o2b3o35bobo9b2o2bo241b2o2b3o35bobo9b2o2bo$326bo3bob3o63bo227bo\n3bob3o291bo3bob3o34bo6b2o2b2o3bo240bo3bob3o34bo6b2o2b2o3bo$326b2obo4bo\n291b2obo4bo291b2obo4bo41b2o7bo240b2obo4bo41b2o7bo$22bobo303bobo297bobo\n297bobo38b2o10b4o243bobo38b2o10b4o$23b2o299bo4bob2o291bo4bob2o291bo4bo\nb2o36b2o243bo9bo4bob2o36b2o$23bo300b3obo3bo291b3obo3bo291b3obo3bo282bo\n8b3obo3bo$27b2o297b3o2b2o293b3o2b2o293b3o2b2o280b3o10b3o2b2o$26bobo\n302bo299bo299bo299bo$b2o25bo301b2o298b2o298b2o298b2o$obo30b2o43b2o$2bo\n29b2o43bobo$34bo44bo$5b2o$4bobo75b2o$6bo74bobo329bobo$83bo329b2o$414bo\n861bo$1275bobo$1275bobo$1271b2o3bo$22b2o1246bo2bo$23b2o74b2o1169bo2bo$\n22bo77b2o1169b2o$49b3o47bo$49bo110b3o$50bo109bo870b2o$161bo869bobo$\n1031bo5$343b3o$345bo$344bo2$366b2o$365b2o$367bo313bobo2bo294bobo2bo\n294bobo2bo$681b3obob2o292b3obob2o292b3obob2o$680bo6bo292bo6bo292bo6bo$\n681bo5b2o292bo5b2o292bo5b2o2$680b2o5bo292b2o5bo292b2o5bo$681bo6bo292bo\n6bo292bo6bo$680b2obob3o292b2obob3o292b2obob3o$682bo2bobo294bo2bobo294b\no2bobo3$901b2o$902b2o40b3o$901bo44bo270bo$945bo271b2o$1216bobo114b2o$\n1332b2o$1334bo$1286b2o$1285bobo$1287bo4$743b2o600bo$742b2o463b2o135b2o\n$744bo463b2o134bobo$1021b3o183bo$410b3o608bo$410bo611bo$411bo788b2o$\n1199bobo$361b2o838bo147b3o$362b2o61b2o165b2o755bo$361bo62b2o167b2o755b\no$426bo165bo2$752b2o$587b2o162b2o$588b2o163bo$587bo6$601b2o$602b2o$\n339b3o259bo$341bo$340bo76b2o366b2o$417bobo156b2o18b2o186b2o$417bo159b\n2o18b2o187bo$576bo19bo$413b2o346b2o$413bobo345bobo26b2o$413bo347bo27b\n2o$791bo4$768bo$767b2o$767bobo!b"]
const cellSize = 4,
    colors = []

let grid = [],
    nGrid = [],
    active = [],
    paused = 0,
    clen = 1,
    delay = 1 / 2.8,
    rules = parseRules(rrog[0]),
    types = rlees,
    currentTypeIndex = 0,
    currentType

function setup() {
    createCanvas(900,901)
    noStroke()
    frameRate(60)
//     background(30,10,128)
    for (let i = 0; i < floor(height / cellSize); i++) {
        grid.push([])
        for (let j = 0; j < floor(width / cellSize); j++) grid[i].push(0)
    }
    colors.push([0, 0, 0])
    colors.push([0, 0, 0])
    for (let c = 0; c < clen - 1; c++) colors.push([floor(random(255)), floor(random(255)), floor(random(255))])

    currentType = parseRLEData2(types[currentTypeIndex])
}

const changeTypeInfo = () => {
        const {rleLength:x,rleHeight:y} = rleBox(currentType[1])
        document.getElementById('t').innerHTML =  currentType[0] + `:  ${x} ${y}`
}


function draw() {
    if (paused) return
        document.getElementById('l').innerHTML = `${frameCount}` // Frame: ${frameCount}`
         document.getElementById('h').innerHTML = `Rule: ${mouseX.toPrecision(3)},${ mouseY.toPrecision(3)} `//${frameRate().toPrecision(2)} ${frameCount}`
    background(255)
// background(30,10,128)

show(grid, colors, cellSize)
    next()
}

const show = (grid, colors, cellSize) => {
    grid.forEach((row, i) => {
        row.forEach((cell, j) => {
            if (cell) {
                fill(colors[floor(cell)][0], colors[floor(cell)][1], colors[floor(cell)][2])
                rect(i * cellSize + 30, j * cellSize, cellSize, cellSize)
            }
        });
    });
}

function next() {
    nGrid = grid.slice()
    const X = nGrid.length - 1,
        Y = nGrid[0].length - 1
    for (let i = 0; i < X + 1; i++) {
        grid[i] = []
        for (let j = 0; j < Y + 1; j++) {
            let numOfNeighbors = 0
            for (let l = -1; l <= 1; l++) {
                for (let m = -1; m <= 1; m++) {
                    if (l == 0 && m == 0) continue
                    numOfNeighbors += nGrid[(i + m + X) % X][(j + l + Y) % Y] == 0 ? 0 : 1
                }
            }
            if (nGrid[i][j] == 0) grid[i][j] = born(numOfNeighbors) ? 1 : 0 //born or die
            else grid[i][j] = survive(numOfNeighbors) ? ((nGrid[i][j] + delay) % clen) : 0 //survive or die
        }
    }
}

const born = (neighborCount) => { return rules[0].includes(neighborCount) }
const survive = (neighborCount) => { return rules[1].includes(neighborCount) }

let counter = 44
function keyPressed() {
        if (key == 's'){
                const zwei = types.length-2,
                pos = [140,100]
                offset = rleBox(parseRLEData2(types[zwei]))
                console.log(offset)
                make(pos, zwei)
                // for(let i = 0; i < counter; i++){next()}
                make([pos[0] - offset.rleHeight + counter,pos[1]], zwei)
                counter++
        }
        if(key == 'c'){grid = clrGrid(grid)}
        if(key == 'a'){grid = ranGrid(grid)}

    if (key == 'f') {
        background(255)
        show(grid, colors, cellSize)
        next()
    }
    if (key == 'p') paused = paused == 1 ? 0 : 1
}

function touchStarted() {
        console.log("touched")
    let pos = [floor(mouseX / cellSize), floor(mouseY / cellSize)]
    if (pos[0] >= 0 && pos[1] >= 0) {
        let mpos = make(pos, currentTypeIndex)
       // // let poop = updateActive2(pos[0], pos[1], mpos[0], mpos[1])
     //   // active.push(poop)
    }
}

function make(pos, type) {
    // WORKING HERE!! trying to return a bounding box from make() to update active by appending curret active with . doubel = sign was problem
    console.log("staynalie",pos, type)
    let x = pos[0],
        y = pos[1]

    currentType = parseRLEData2(types[type])
//     console.log("make",currentType)
    let instructs = currentType[1]

    for (let i = 0; i < instructs.length; i++) { // i = rows or y
        // console.log("this is i",i)
        if(i%10==0)console.log("same but tens",i, instructs[i].length)
        if(!instructs[i].length) continue
        for (let j = 0; j < instructs[i].length; j++) {
                // console.log("this is j",j)
                grid[x + i][y + j] = instructs[i][j]}//swapped
    }
}

const rleBox = (type) => {
        let rleLength = 0,
        rleHeight = type.length 
        type.forEach(row=>{
                if(row.length > rleLength) rleLength = row.length
        })
        return {rleLength,rleHeight}
} 

function cellsToCheck2(wid, hei, ar) { // frame
    // active = cellsToCheck(Xo, Yo, active)
    let aC = []
    let arr = ar //should just be the active arr here idk why [0] is needed
    if (!arr) return []
    for (let i = 0; i < arr.length; i++) {
        if (grid[arr[i][0]][arr[i][1]] == 1) {
            for (let j = -1; j < 2; j++) {
                for (let k = -1; k < 2; k++) aC.push([(arr[i][0] + j + wid) % wid, (arr[i][1] + k + hei) % hei])
            }
        }
    }
    return Array.from(new Set(aC.map(JSON.stringify)), JSON.parse);
}

function updateActive2(x1, y1, x2, y2) { //touch
    let activ = []
    let X = grid.length - 1,
        Y = grid[0].length - 1
    for (let i = x1; i < x1 + x2; i++) {
        for (let j = y1; j < y1 + y2; j++) {
            if (grid[i][j] == 1) {
                for (let m = -1; m < 2; m++) {
                    for (let k = -1; k < 2; k++) activ.push([(i + m + X) % X, (j + k + Y) % Y])
                }
            }
        }
    }
    return Array.from(new Set(activ.map(JSON.stringify)), JSON.parse);
}

const ranGrid = (grid) => {
    const randomGrid = []
    grid.forEach(row => {
        const tempArray = []
        row.forEach(cell => tempArray.push(floor(random(2))))
        randomGrid.push(tempArray)
    })
    return randomGrid
}

const clrGrid = (grid) => {
    const clearGrid = []
    grid.forEach((row) => {
        const tempArray = []
        row.forEach(cell => tempArray.push(0))
        clearGrid.push(tempArray)
    })
    return clearGrid
}



const htmlalterations = () => {
        let chars = ['1', '2', '(', '3', 'C', '4', 'F', '5', '6', 'S', '7', '8', 'L', '9', 'A', 'a', 'B', 'b', 'c', 'D', 'd', 'O', 'E', 'e', 'f', 'g', 'G', 'H', 'h', 'i', 'I', 'J', 'j', 'K', 'k', 'l', 'M', 'm', 'n', 'o', 'p', 'P', 'Q', 'q', 'R', 'r', '$', 's', 'T', 't', 'U', 'u', 'V', 'v', 'w', 'W', 'X', 'Y', 'z', 'Z']
        chars.forEach(start=>{
                const searchBtn = document.createElement('p')
                searchBtn.className = "searchbtn"
                searchBtn.id = start + "btn"
                searchBtn.textContent = start
                searchBtn.style = "display:inline;"
                searchBtn.onclick = ()=> currentTypeIndex = firstTypeWStart(start)
                const actionBar = document.getElementById('actionBar')
                actionBar.appendChild(searchBtn)
        })
}

const firstTypeWStart = (start)=>{
        for(let i = 0; i < types.length; i++){
                if(types[i].search(/[^#N ]/g) == start) return i
        }
}
